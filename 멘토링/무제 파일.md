# JCF(Java Collections Framework)
![](../image/Pasted%20image%2020240423230904.png)
- List
- Map
- Set

📌객체들을 효율적으로 추가 / 삭제 / 검색할 수 있도록 한다. 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것.

📌JDK 1.2 이전까지는 Vector / Hashtable, Properties와 같은 컬렉션 클래스들을 서로 다른 각자의 방식으로 처리해야 했으나, JDK1.2부터 컬랙션 프레임워크가 등장하면서 다양한 종류의 컬렉션 클래스가 추가되고 모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있도록 체계화되었다.

📌왜 사용할까?
- 인터페이스와 다형성을 이용한 객체지향적 설계로 표준화되어 있기 때문에 사용법을 익히기 편리하고 재사용성이 높다.
- 데이터 구조 및 알고리즘을 고성능으로 구현한 것이어서 프로그램 성능과 품질을 향상시킨다.

📌주의 !! 컬렉션 프레임워크에 저장할 수 있는 데이터는 오로지 객체(Object) 뿐이다. primitive 타입은 포함시킬 수 없다. (이 문제는 wrapper class 개념으로 이어진다)

<br><br><


## Iterable 인터페이스
![](../image/Pasted%20image%2020240423224758.png)
- 컬렉션 인터페이스의 가장 최상위 인터페이스
- 컬렉션에 담긴 요소들을 하나씩 순회할 때 이터레이터 객체를 활용하는데, 이러한 이터레이터 객체를 관리하는 인터페이스스

## List 인터페이스
![](../image/Pasted%20image%2020240423224949.png)
📌특징
- 저장 순서가 유지되어야 하는 컬렉션을 구현하는 데 사용
- 같은 요소의 중복 저장 허용
- index로 요소에 접근
- 배열(array)과 달리 자료형 크기가 고정 되어 있지 않고, 데이터 양에 따라 동적으로 변한다.
- 요소 사이에 빈공간을 허용하지 않는다 -> 삽입/삭제 할 때마다 배열 이동이 일어난다.


## Queue 인터페이스
![](../image/Pasted%20image%2020240423231010.png)
📌특징
- 선입선출 FIFO(First In First Out) 구조
- 필요에 따라 우선순위를 부여하여 정렬하는 PriorityQueue 클래스 / 양쪽으로 넣고 빼는 것이 가능한 ArrayDeque 클래스 등으로 구현한다.
![](../image/Pasted%20image%2020240423231533.png)
![](../image/Pasted%20image%2020240423231525.png)



## Set 인터페이스
![](../image/Pasted%20image%2020240423231328.png)
📌특징
- 데이터 중복을 허용하지 않고 순서를 유지하지 않는 데이터 집합.
- 순서 자체가 없으므로 인덱스를 검색해서 가져오는 메소드도 없다.
- 중복 저장이 불가능하기 때문에 null 값도 하나만 저장할 수 있다.

📌HashSet 클래스
![](../image/Pasted%20image%2020240423232001.png)
- 배열과 연결 노드를 결합한 자료구조 형태.
- 가장 빠른 임의 검색 접근 속도를 가진다.
- 추가 / 삭제 / 검색 / 접근성 모두 뛰어나다.
- 순서를 전혀 예측할 수 없다.

```java
Set<Integer> hashSet = new HashSet<>();

hashSet.add(10);
hashSet.add(20);
hashSet.add(30);
hashSet.add(10); // 중복된 요소 추가

hashSet.size(); // 3 - 중복된건 카운트 X

hashSet.toString(); // [20, 10, 30] - 자료 순서가 뒤죽박죽
```



📌TreeSet 클래스
![](../image/Pasted%20image%2020240423232143.png)
- 이진 검색 트리 자료구조 형태로 데이터 저장.
- 중복 허용하지 않고, 순서 없다.
- 데이터를 (알아서) 정렬하여 저장하고 있다.
- 정렬 / 검색 / 범위 검색에서 성능이 좋다.
```java
Set<Integer> treeSet = new TreeSet<>();

treeSet.add(7);
treeSet.add(4);
treeSet.add(9);
treeSet.add(1);
treeSet.add(5);

treeSet.toString(); // [1, 4, 5, 7, 9] - 자료가 알아서 정렬됨
```
![](../image/Pasted%20image%2020240423232309.png)



## Map 인터페이스
![](../image/Pasted%20image%2020240423232329.png)
📌특징
- 키(key)와 값(value) 쌍으로 연관되어 이루어진 데이터 집합
- value는 중복 저장할 수 있지만, key는 해당 map에서 고유하다
- 기존에 저장된 데이터와 중복된 key 값을 저장하면, 기존 값은 사라지고 마지막에 입력한 값만 저장된다.
- 저장 순서가 유지되지 않는다.

📌HashMap 클래스
![](../image/Pasted%20image%2020240423232548.png)
- 배열과 연결이 결합된 Hashing 형태로, key / value를 묶어 하나의 데이터로 저장한다.
- 중복을 허용하지 않고, 순서를 보장하지 않는다.
- key / value 로 null값을 허용한다.
- 추가 / 삭제 / 검색 / 접근성 모두 뛰어나다.
- 비동기로 작동하므로 멀티쓰레드 환경에서 어울리지 않는다.
```java
Map<String, String> hashMap = new HashMap<>();

hashMap.put("love", "사랑");
hashMap.put("apple", "사과");
hashMap.put("baby", "아기");

hashMap.get("apple"); // "사과"

// hashmap의 key값들을 set 집합으로 반환하고 순회
for(String key : hashMap.keySet()) {
    System.out.println(key + " => " + hashMap.get(key));
}
/*
love => 사랑
apple => 사과
baby => 아기
*/
```
