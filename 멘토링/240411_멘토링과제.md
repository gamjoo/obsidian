# Java의 특징
1.운영체제에 독립적
2.객체지향언어
3.자동메모리관리(Garbage Collection)
4.네트워크 / 분산처리 지원
5.멀티쓰레드(multi-thread)
7.동적 로딩(Dynamic Loading)
- 인터프리터 방식의 단점 보완. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드(.class) 전체를 컴파일하여 기계어로 변경하고, 이후에는 해당 프로그램을 더 이상 인터프린팅 하지 않고 기계어로 직접 실행하는 방식.
- 기계어(컴파일된 코드)는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행하게 된다.
- 자바 컴파일러가 자바 프로그램 코드를 바이트 코드(.class)로 변환한 다음, 실제 바이트 코드를 실행하는 시점에 바이트 코드를 JIT 컴파일을 통해 기계어로 변환한다.
# JDK vs JRE
## JDK
★자바개발도구(Java Development Kit)
★JDK = JRE + 개발에 필요한 실행파일 (javac.exe 등)
- Javac.exe는 Java Compiler를 의미한다. JDK를 설치하면 bin 폴더에 존재한다.

## JRE
★자바실행환경(Java Runtime Environment)
- 자바로 작성된 응용프로그램이 실행되기 위한 최소환경
★JRE = JVM + 클래스라이브러리(Java API)
# Java 실행방식
★Hello.java ----javac.exe----> Hello.class ----java.exe----> 실행
- 자바 컴파일러(javac.exe)를 사용해서 소스파일(Hello.java)로부터 클래스파일(Hello.class)를 생성한다. 그 다음 자바 인터프리터(java.exe)로 실행한다.
- (1)프로그램의 실행에 필요한 클래스(\*.class 파일)를 로드한다 -> (2)클래스파일을 검사한다(파일형식/악성코드 체크) -> (3)지정된 클래스에서 main(String\[] args)를 호출한다.
- 엥? 그러면 JVM은 어느 과정에서 관여하는 거야

# 인터프린터 언어 vs 컴파일 언어
★공통점
- 고급 언어로 작성된 원시 프로그램(source program)을 목적 프로그램(object program)으로 번역하는 프로그램. 다만, 프로그램 번역 방식에 따라 구분된다.

★컴파일러
- 고급 프로그래밍 언어로 작성한 Source Code를 컴퓨터 내부에서 사용 가능한 언어인 기계어(Machine Language)로 번역하고, 이를 실행가능 하게 만들어 주는 프로그램.
★컴파일 언어
- 컴파일러를 통해 컴파일 타임에 전체 소스 코드를 한 번에 기계어로 변환 후 실행파일을 만든다.
- 컴파일 단계와 실행 단계가 각각 분리되어 있으며, 컴파일은 단 한번만 수행된다.
- 실행은 실행 파일을 실행시킴으로써 할 수 있으며, 실행시에는 컴파일 과정을 거치지 않고 실행만 하면 되므로 코드 실행 속도가 빠르다. 단, 프로젝트의 규모가 클 경우 컴파일 시간이 오래 걸릴 수 있다.
- C, C++, C# 등 ...

★인터프리터
- 소스를 한꺼번에 번역하지 않고 명령어 문장 단위로 하나씩 읽어들여 번역과 동시에 실행하는 프로그램.
★인터프린터 언어
- 컴파일 과정을 거치지 않는다.
- 한번에 적은 양의 내용을 추가하고 빠르게 테스트 해볼 수 있다.
- 프로그래밍을 대화식으로 할 수 있다.
-  Python, JavaScript, Ruby 등..

★자바?
- JAVA는 다른 컴파일 언어들이 작동하듯이 컴파일러를 이용해 전체 코드를 한번에 번역한다. 여기서 사용하는 컴파일러를 자바 컴파일러(javac.exe)라고 한다. 이 자바 컴파일러는 Java 코드를 JVM이 실행시킬 수 있는 자바 바이트코드(.class)로 번역한다.
- 이렇게 작성된 자바 바이트 코드(.class)는 JVM의 자바 인터프린터(Java Interpreter)를 이용해 한 줄씩 실행된다. 자바 바이트 코트로 작성되어 있는 실행 프로그램을 자바 인터프리터(java.exe)가 한 줄씩 읽으면서 컴퓨터가 이해할 수 있는 2진 코드로 번역한 후 명령을 실행한다.
![](../image/Pasted%20image%2020240417214257.png)
# Java가 플랫폼에 독립적인 이유
★자바 응용프로그램은 운영체제나 하드웨어가 아닌 JVM하고만 통신한다. JVM은 자바 응용프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달한다. 자바로 작성된 프로그램은 운영체제에 독립적이지만 JVM은 운영체제에 종속적이어서 썬에서는 여러 운영체제에 설치할 수 있는 서로 다른 버전의 JVM을 제공하고 있다. 그래서 자바로 작성된 프로그램은 운영체제와 하드웨어에 관계없이 실행 가능하며 이것을 '한번 작성하면, 어디서나 실행된다. (Write Once run anywhere)' 라고 표현하기도 한다.

★기계어 -> 어셈블리어 -> C언어 -> 자바
- 어셈블리어 : 기계어의 가독성 개선 but 기계에 따라 어셈블리어가 영향을 받는다. (A사에서 만든 컴퓨터, B사에서 만든 컴퓨터에 따라 다른 어셈블리어가 존재한다...)
- ![](../image/ASSEMBLER.png)
- C : 단 하나의 소스 코드만 작성하며, 기계에 맞는 컴파일러가 각 기계에 맞는 목적 파일을 만든다. WOCA(Write Once Compile Anywhere -> but 운영체제마다 컴파일러가 다름... )
- ![](../image/C언어.png)
- Java : WORA(Write Once Run Anywhere). C언어가 운영체제마다 컴파일러를 따로 구비해두고 있어야 하는 단점 보완. (아니 근데, 어차피 자바도 JRE를 운영체제에 따라 세팅해줘야 하는 거 아님? 그러면 컴파일러 구비해두는 거랑, JRE 세팅해두는 거랑 별 차이가 없는 것 같은데..?)
  - "플랫폼에 독립적" 이라는 말은 정확히, java 어플리케이션이 운영체제에 독립적이라는 의미다. JVM은 운영체제에 종속적이다. JVM에 포함된 JIT(Just In Time) Compiler가 바이트코드(,class)를 운영체제별로 다르게 변환해야 하기 때문이다.
  - ![](../image/JVM.png)
  - .class 형식의 파일은 JVM이 읽을 수 있는 형식이다. 운영체제가 읽을 수 있는 형식이 아니다. 운영체제가 이해할 수 있게 하려면 한번 더 변환이 필요하다.
  - 자바는 `동적 로딩(Dynamic Loading)`을 지원하기 때문에, JVM은 해당 .class 파일이 필요한 시점에 로딩하여 해당 운영체제가 이해할 수 있는 언어로 다시 변환한다(bytecode는 기계어가 아니기 때문에 OS에서 바로 실행되지 않는다). 이를 JIT compiler가 수행한다.
  - JIT Compiler는 Windows, Linux 등 각 운영체제가 이해할 수 있는 언어로 변환하여 준다. JIT Compiler가 운영체제가 이해할 수 있는 언어로 변환을 잘 할 수 있도록 운영체제에 맞는 JIT Compiler를 설치해야 한다.

# JVM 구조
![](../image/JVM구조.png)
★전체 구성
- 클래스 로더(Class Loader)
- 실행 엔진(Execution Engine)
  - 인터프리터(Interpreter)
  - JIT 컴파일러(Just-In-Time compiler)
  - 가비지 콜렉터(Garbage collector)
- 런타임 데이터 영역(Runtime Data Area)
  - 메소드 영역
  - 힙 영역
  - PC Register
  - 스택 영역
  - 네이티브 메소드
★클래스 로더(Class Loader)
![](../image/Pasted%20image%2020240417235156.png)
- (1)Loading : 클래스 파일을 가져와서 JVM 메모리에 로드
- (2)Linking : 클래스 파일을 사용하기 위해 검증
- (3)Initialization : 클래스 변수들을 적절한 값으로 초기화
★실행 엔진 (Excution Engine) : 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다. 자바 바이트 코드(.class)는 JVM이 이해할 수 있는 중간 레벨로 컴파일 된 코드다. 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경해준다. 이 수행 과정에서 실행 엔진은 `인터프리터`와 `JIT 컴파일러` 두 가지 방식을 혼합하여 바이트 코드를 실행한다.
- ![](../image/Pasted%20image%2020240418000258.png)
- 인터프리터(Interpreter) : 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행한다. JVM안에서 바이트코드는 기본적으로 인터프리터 방식으로 동작한다. 다만 같은 메소드 라도 여러번 호출이 된다면 매번 해석하고 수행해야 돼서 전체적인 속도는 느리다.
- JIT 컴파일러(Just-In-Time Compiler) : 위의 Interpreter의 단점을 보완하기 위해 도입된 방식으로 반복되는 코드를 발견하여 바이트 코드 전체를 컴파일하여 Native Code로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고 캐싱해 두었다가 네이티브 코드로 직접 실행하는 방식이다.  하나씩 인터프리팅하여 실행하는것이 아니라, 컴파일된 네이티브 코드를 실행하는 것이기 때문에 전체적인 실행 속도는 인터프리팅 방식보다 빠르다.  하지만 바이트코드를 `Native Code(JAVA에서 부모가 되는 C언어나, C++, 어셈블리어로 구성된 코드를 의미한다)`로 변환하는 데에도 비용이 소요되므로, JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고 인터프리터 방식을 사용하다 일정 기준이 넘어가면 JIT 컴파일 방식으로 명령어를 실행하는 식으로 진행한다.




![](../image/JVM_runtime_data_area.png)
# 스레드 vs 프로세스


# GC(Garbage Collection)


### reference
- https://velog.io/@outgrow0905/java%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%97%90-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B4%EB%9D%BC%EB%A9%B4%EC%84%9C-%EC%99%9C-%EC%84%A4%EC%B9%98%ED%95%A0-%EB%95%8C%EC%97%90%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%97%90-%EB%A7%9E%EC%B6%B0%EC%84%9C-%EC%84%A4%EC%B9%98%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C
- https://jaeseongdev.github.io/development/2021/03/08/%EC%9E%90%EB%B0%94%EC%9D%98_%EA%B0%80%EC%9E%A5_%ED%81%B0_%EC%9E%A5%EC%A0%90_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%97%90_%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B4%EB%8B%A4/
- https://doozi0316.tistory.com/entry/1%EC%A3%BC%EC%B0%A8-JVM%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80
-  [https://inpa.tistory.com/entry/JAVA-☕-JVM-내부-구조-메모리-영역-심화편](https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8) [Inpa Dev 👨‍💻:티스토리]