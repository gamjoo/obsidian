# 기본자료형 vs 참조자료형
📌기본형 변수는 실제 값(data)를 저장한다. 참조형 변수는 어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다(4byte 정수). 자바는 C언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두 기본형 변수다.

📌기본자료형 (Primitive)

| 자료형     | 메모리사이즈 |
| ------- | ------ |
| byte    | 1byte  |
| short   | 2byte  |
| int     | 4byte  |
| long    | 8byte  |
| float   | 4byte  |
| double  | 8byte  |
| boolean | 1byte  |
| char    | 2byte  |

📌참조자료형 (Reference) : 8가지 기본형을 제외한 나머지 타입.
- 클래스 (Class)
- 인터페이스 (Interface)
- 열거형 (Enum)                                                                                               
📌기본형과 참조형 모두 변수의 공간이 스택 메모리에 생성되지만 그 공간에 저장되는 값의 의미가 다르다. 기본형은 스택 메모리에 생성된 공간에 실제 변수의 값(리터럴)을 저장하는 반면, 참조형은 실제 데이터의 값은 힙 메모리에 저장하고, 스택 메모리의 변수 공간에는 실제 변수값이 저장된 힙 메모리의 주소(위치값)를 저장한다.
- 자바는 힙 메모리에 직접 접근할 수 없으므로, 참조형 변수의 실제 데이터 값에 접근하기 위해서는 반드시 위치값을 저장하고 있는 참조변수가 필요하다.
![](../image/memory_stack_heap.jpg)




# String
![](../image/Pasted%20image%2020240423000532.png)
📌java.lang 패키지에 포함되고, Object 클래스를 상속하고 있으며, Serializable 등의 interface를 구현하고 있다.
📌문자열을 저장하고 이를 다루는데 필요한 여러 메서드를 제공한다.
📌한번 생성된 String인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고, 변경할 수는 없다.  예를 들어 아래 코드와 같이 + 연산자를 이용하여 문자열을 결합하는 경우 인스턴스 내의 문자열이 바뀌는 것이 아니라, 새로운 문자열("ab")이 담긴 String  인스턴스가 생성된다.
```java
String a = "a";
String b = "b";
String a = "a+b";
```
📌문자열을 만들 때는 (1)문자열 리터럴을 지정하는 방법 (2)String 클래스의 생성자를 사용해서 만드는 방법. 두 가지가 있다.
```java
String str1 = "abc";
String str2 = "abc";
String str3 = new String("abc");
String str4 = new String("abc");
```
![](../image/Pasted%20image%2020240423001529.png)
이 그림은 동등성 / 동일성 개념과 이어진다.

📌여러 메서드가 있다...
📌casting
📌StringBuffer / StringBuilder



# 동등성(**equality)** vs 동일성(identity)
📌동일성은 동일하다는 뜻으로, 두 개의 객체가 완전히 같은 경우를 의미한다. 완전히 같다는 뜻은 두 객체가 사실상 하나의 객체로 봐도 무방하며, 주소 값이 같기 때문에 두 변수가 같은 객체를 가리키게 된다.
![](../image/Pasted%20image%2020240423002238.png)
📌해당 변수가 동일한지는 == 연산자를 통해 판별할 수 있다.

📌동등성은 동등하다는 뜻으로 두 개의 객체가 같은 정보를 갖고 있는 경우를 의미힌다. 동등성은 변수가 참조하고 있는 객체의 주소가 서로 다르더라도 내용만 같으면 두 변수는 동등하다고 할 수 있다('동일하다'는 '동등하다'의 충분조건). 동일하면, 동등하지만 동등하다고 동일한 것은 아니다. 해당 변수가 동등한지는 equals 연산자를 통해 판별할 수 있다.

📌주의 !! 어떠한 객체든 equals 연산자만 사용하면 두 객체에 대한 동등성 판단이 가능한 것은 아니다.
```java
public boolean equals(Object obj) {
  return (this == obj);
}
```
이 메소드는 모든 객체의 조상인 Object 객체에서 정의하고 있는 equlas()메소드다. 반환 형태를 보면 알 수 있듯, 단순히 동일성 비교만 하고 있다. 즉, 해당 메소드를 자식 객체에서 재정의하지 않는 이상 equals()연산자는 \==연산자와 다르지 않다.

📌String 클래스에서는 equals() 메서드를 오버라이딩하여 다음과 같이 정의하고 있다.
```java
public boolean equals(Object anObject) {
  if(this == anObject) {
    return true;
  }
  if (anObject instanceof String) {
    String anotherString = (String) anObject;
    int n = value.length;
    if (n == anotherString.value.length) {
      char v1[] = value;
      char v2[] = anotehrString.value;
      int i = 0;
      while (n-- != 0) {
        if (v1[i] != v2[i])
          return false;
		 i++
      }
      return true;
    }
  }
  return false;
}
```
equals()의 인자로 전달된 String의 문자열을 비교하고 있다. \== 연산자를 통해 두 객체의 `동일성 여부`를 판단하고, 두 객체가 동일하지 않다면 String인지 여부를 판단한 뒤, 문자 하나 하나가 같은지 비교한다. 만약 모든 문자가 같다면 두 객체의 내용이 같은 것이므로 `동등`하다고 판별할 수 있다.

# Object Class
- toString()
- equals()
- hashCode()
📌Object 클래스는 전체 클래스 계층 구조에서 root에 해당한다. 모든 클래스는 부모 클래스로 Object 클래스를 상속한다. 

# JCF(Java Collections Framework)

- List
- Map
- Set

# Array vs List vs ArrayList



# ArrayList vs LinkedList



# Generic



# Wrapper Class
📌기본 자료형을 감싸는(?) 클래스.
- int 형의 Wrapper Class 이름 주의. 다른 Wrapper Class들은 primitive 이름에 첫 글자만 대문자로 바꾼 형태인데, int 형만 예외로 Integer.

📌왜 사용할까?
- 클래스에서 제공하는 유용한 메소드를 활용할 수 있다.
- Generic을 활용할 수 있다. Generic에 사용되는 매개변수는 Object 형만 받을 수 있다. 즉, 참조형 변수만 입력할 수 있는데, Wrapper 클래스를 활용하면 기본형을 Generic에 활용할 수 있다.





### reference
📚 [velog.io/@1205kjw/2.3.1-기본-자료형과-참조-자료형의-차이](https://velog.io/@1205kjw/2.3.1-%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95%EA%B3%BC-%EC%B0%B8%EC%A1%B0-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%98-%EC%B0%A8%EC%9D%B4)
📚 https://blog.naver.com/dkfm214/221912369571
📚 [Java 동일성(identity)과 동등성(equality)](https://steady-coding.tistory.com/534)