# 기본자료형 vs 참조자료형
📌기본형 변수는 실제 값(data)를 저장한다. 참조형 변수는 어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다(4byte 정수). 자바는 C언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두 기본형 변수다.

📌기본자료형 (Primitive)

| 자료형     | 메모리사이즈 |
| ------- | ------ |
| byte    | 1byte  |
| short   | 2byte  |
| int     | 4byte  |
| long    | 8byte  |
| float   | 4byte  |
| double  | 8byte  |
| boolean | 1byte  |
| char    | 2byte  |

📌참조자료형 (Reference) : 8가지 기본형을 제외한 나머지 타입.
- 클래스 (Class)
- 인터페이스 (Interface)
- 열거형 (Enum)                                                                                               
📌기본형과 참조형 모두 변수의 공간이 스택 메모리에 생성되지만 그 공간에 저장되는 값의 의미가 다르다. 기본형은 스택 메모리에 생성된 공간에 실제 변수의 값(리터럴)을 저장하는 반면, 참조형은 실제 데이터의 값은 힙 메모리에 저장하고, 스택 메모리의 변수 공간에는 실제 변수값이 저장된 힙 메모리의 주소(위치값)를 저장한다.
- 자바는 힙 메모리에 직접 접근할 수 없으므로, 참조형 변수의 실제 데이터 값에 접근하기 위해서는 반드시 위치값을 저장하고 있는 참조변수가 필요하다.
![](../image/memory_stack_heap.jpg)




# String
![](../image/Pasted%20image%2020240423000532.png)
📌java.lang 패키지에 포함되고, Object 클래스를 상속하고 있으며, Serializable 등의 interface를 구현하고 있다.
📌문자열을 저장하고 이를 다루는데 필요한 여러 메소드를 제공한다.
📌한번 생성된 String인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고, 변경할 수는 없다.  예를 들어 아래 코드와 같이 + 연산자를 이용하여 문자열을 결합하는 경우 인스턴스 내의 문자열이 바뀌는 것이 아니라, 새로운 문자열("ab")이 담긴 String  인스턴스가 생성된다.
```java
String a = "a";
String b = "b";
String a = "a+b";
```
📌문자열을 만들 때는 (1)문자열 리터럴을 지정하는 방법 (2)String 클래스의 생성자를 사용해서 만드는 방법. 두 가지가 있다.
```java
String str1 = "abc";
String str2 = "abc";
String str3 = new String("abc");
String str4 = new String("abc");
```
![](../image/Pasted%20image%2020240423001529.png)
이 그림은 동등성 / 동일성 개념과 이어진다.

📌여러 메소드가 있다...
📌casting
📌StringBuffer / StringBuilder



# 동등성(**equality)** vs 동일성(identity)
📌동일성은 동일하다는 뜻으로, 두 개의 객체가 완전히 같은 경우를 의미한다. 완전히 같다는 뜻은 두 객체가 사실상 하나의 객체로 봐도 무방하며, 주소 값이 같기 때문에 두 변수가 같은 객체를 가리키게 된다.
![](../image/Pasted%20image%2020240423002238.png)
📌해당 변수가 동일한지는 == 연산자를 통해 판별할 수 있다.

📌동등성은 동등하다는 뜻으로 두 개의 객체가 같은 정보를 갖고 있는 경우를 의미힌다. 동등성은 변수가 참조하고 있는 객체의 주소가 서로 다르더라도 내용만 같으면 두 변수는 동등하다고 할 수 있다('동일하다'는 '동등하다'의 충분조건). 동등하다고 항상 동일한 것은 아니다. 해당 변수가 동등한지는 equals 연산자를 통해 판별할 수 있다.

📌주의 !! 어떠한 객체든 equals 연산자만 사용하면 두 객체에 대한 동등성 판단이 가능한 것은 아니다.
```java
public boolean equals(Object obj) {
  return (this == obj);
}
```
이 메소드는 모든 객체의 조상인 Object 객체에서 정의하고 있는 equlas()메소드다. 반환 형태를 보면 알 수 있듯, 단순히 동일성 비교만 하고 있다. 즉, 해당 메소드를 자식 객체에서 재정의하지 않는 이상 equals()연산자는 \==연산자와 다르지 않다.

📌String 클래스에서는 equals() 메소드를 오버라이딩하여 다음과 같이 정의하고 있다.
```java
public boolean equals(Object anObject) {
  if(this == anObject) {
    return true;
  }
  if (anObject instanceof String) {
    String anotherString = (String) anObject;
    int n = value.length;
    if (n == anotherString.value.length) {
      char v1[] = value;
      char v2[] = anotehrString.value;
      int i = 0;
      while (n-- != 0) {
        if (v1[i] != v2[i])
          return false;
		 i++
      }
      return true;
    }
  }
  return false;
}
```
equals()의 인자로 전달된 object 문자열을 비교하고 있다. \== 연산자를 통해 두 객체의 `동일성 여부`를 판단하고, 두 객체가 동일하지 않다면 String 객체로 형변환 가능한지 여부를 확인한 뒤, 문자 하나 하나가 같은지 비교한다. 만약 모든 문자가 같다면 두 객체의 내용이 같은 것이므로 `동등`하다고 판별할 수 있다.

# Object Class
- toString()
- equals()
- hashCode()



📌Object 클래스는 전체 클래스 계층 구조에서 root class에 해당한다. 모든 클래스는 부모 클래스로 Object 클래스를 상속한다.  (extends .. 로 명시적으로 상속하지 않아도 자동으로 상속이 이뤄진다. 만일 다른 클래스를 extends.. 하더라도 클래스는 1개밖에 상속할 수 없지만, 상속한 그 부모 클래스가 Object를 상속할 것이기 때문에 결국 모든 클래스는 Object 클래스를 상속받는 형태가 된다.)

📌public String toString()
```java
public String toString() {return getClass().getName() + "@" + Integer.toHexString(hashCode()); }
```
- 객체 자신의 정보(해당 인스턴스에 대한 정보와 주소(해쉬코드))를 문자열로 반환
  - 해쉬코드는 인스턴스의 주소를 hashing하여 변환한 값으로, 인스턴스마다 다르게 반환된다.
- 객체의 이름이나 주소값이 아닌, 객체의 고유 정보(담겨 있는 데이터)를 출력하고 싶을 때는 오버라이딩하여 반환값을 다르게 설정한다.
- 객체를 출력하는 명령 (예를 들면, Student student = new Stundet(); System.out.println(student))을 수행할 때, 변수에 toString()를 호출하지 않아도 자동으로 붙여서 호출한다.

📌public boolean equals(Object obj)
```java
public boolean equals(Object obj) {
	return (this == obj);
}
```
- 객체 자신과 객체 obj가 같은 객체인지 알려준다 (같으면 true)



📌public native int hashCode()
- 객체의 주소값을 해쉬코드로 반환한다. 객체의 주소가 아닌 다른 데이터의 주소를 반환하려면 오버라이딩하여 재정의 해주어야 한다.
- equals()의 결과가 true인 두 객체의 해쉬코드는 반드시 같아야 한다는 자바의 규칙..?
- equals 메소드와 hashcode 메소드, 두 메소드를 override 하지 않으면, hash 값을 사용하는 Collection Framework(HashSet / HashMap / HashTable)을 사용할 때 문제가 발생한다.
```java
package overridesample;  
  
import java.util.*;  
  
class Human {  
    public String name;  
  
    public Human(String name) {  
        this.name = name;  
    }  
  
    public boolean equals(Object obj) {  
        if (this == obj) return true;  
        if (obj == null || getClass() != obj.getClass()) return false;  
        Human so = (Human) obj;  
        return Objects.equals(name, so.name);  
    }  
}  
  
public class ClassTest {  
    public static void main(String[] args) {  
        Human h1 = new Human("고라니");  
        Human h2 = new Human("고라니");  
  
        //두 객체는 '동일'하지는 않음  
        System.out.println(h1); //overridesample.Human@b4c966a  
        System.out.println(h2); //overridesample.Human@2f4d3709  
  
        //두 객체의 해쉬 코드  
        System.out.println(h1.hashCode()); // 189568618  
        System.out.println(h2.hashCode()); // 793589513  
  
        //해쉬코드가 달라도, equals 메소드를 재정의했으므로 true 반환.  
        System.out.println(h1.equals(h2));  
  
        //리스트를 생성하고 두 객체를 추가한다.  
        List<Human> list = new ArrayList<Human>();  
        list.add(h1);  
        list.add(h2);  
        System.out.println(list.size()); //2  
  
        //중복을 허용하지 않는 Set 자료형  
        Set<Human> set = new HashSet<Human>();  
        set.add(h1);  
        set.add(h2);  
        System.out.println(set.size()); //2  
    }  
}
```
![](../image/Pasted%20image%2020240423215449.png)
- hash 값을 사용하는 Collection은 객체가 논리적으로 같은지 비교할 때 위 그림과 같은 과정을 거친다. (1)컬렉션에 데이터가 추가되면 그 데이터의 hashcode()리턴 값을 컬렉션에 가지고 있는지 비교한다 (2)해쉬코드가 같으면 다음으로 equals()메소드 리턴 값을 비교하고 (3)true이면 논리적으로 같은 객체로 판단한다.
- 위 코드에서 HashSet에 Human 객체를 추가할 때도 위와 같은 과정으로 중복 여부를 판단하고 HashSet에 추가한다. Human 클래스에서는 hashCode 메소드가 오버라이드 되지 않아서 Object 클래스의 hashCode 메소드가 사용되고, 객체마다 다른 값을 리턴했다. 결국, h1 / h2 객체는 euqals 메소드로 비교 하기 전에 서로 다른 hashCode 메소드 리턴값으로 인해 다른 객체로 판단되어 size 메소드의 반환값이 '2'로 나온 것이다. 이런 오작동을 방지하기 위해 hashCode 메소드도 오버라이드 하여 equals 메소드의 반환값이 true인 두 객체는 같은 해쉬코드를 갖도록 오버라이드 할 필요가 있다.

# JCF(Java Collections Framework)

- List
- Map
- Set

# Array vs List vs ArrayList



# ArrayList vs LinkedList



# Generic



# Wrapper Class
📌기본 자료형을 감싸는(?) 클래스.
- int 형의 Wrapper Class 이름 주의. 다른 Wrapper Class들은 primitive 이름에 첫 글자만 대문자로 바꾼 형태인데, int 형만 예외로 Integer.

📌왜 사용할까?
- 클래스에서 제공하는 유용한 메소드를 활용할 수 있다.
- Generic을 활용할 수 있다. Generic에 사용되는 매개변수는 Object 형만 받을 수 있다. 즉, 참조형 변수만 입력할 수 있는데, Wrapper 클래스를 활용하면 기본형을 Generic에 활용할 수 있다.





### reference
📚 [velog.io/@1205kjw/2.3.1-기본-자료형과-참조-자료형의-차이](https://velog.io/@1205kjw/2.3.1-%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95%EA%B3%BC-%EC%B0%B8%EC%A1%B0-%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%98-%EC%B0%A8%EC%9D%B4)
📚 https://blog.naver.com/dkfm214/221912369571
📚 [Java 동일성(identity)과 동등성(equality)](https://steady-coding.tistory.com/534)
📚[https://inpa.tistory.com/entry/JAVA-☕-Object-클래스와-상위-메소드-재정의-활용-총정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-Object-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%83%81%EC%9C%84-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9E%AC%EC%A0%95%EC%9D%98-%ED%99%9C%EC%9A%A9-%EC%B4%9D%EC%A0%95%EB%A6%AC) [Inpa Dev 👨‍💻:티스토리]