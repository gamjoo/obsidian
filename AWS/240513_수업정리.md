# Jenkins 이어서
## 프리티어는 속도가 너무 느림..
![](../image/Pasted%20image%2020240513090819.png)

![](../image/과정1_배포.txt)

📌인스턴스 유형을 바꿔야 할 것 같다...

![](../image/Pasted%20image%2020240513093049.png)

📌결국 .. 다시 한다.

![](../image/Pasted%20image%2020240513093103.png)

📌엄청 빠르다.. 2배 정도?

📌jenkins url : http://54.180.113.25:8080/

![](../image/Pasted%20image%2020240513095022.png)

📌훨씬.. 빠르게(33초..) 빌드가 완료된 것을 볼 수 있다

![](../image/Pasted%20image%2020240513103747.png)


## jenkins에서 scm 적용하기
📌젠킨스에서 SCM 적용하기

pipeline script를 깃에서 가져와서 작동하도록 합니다. 이 때 SCM 을 이용합니다.
"Pipeline script from SCM"은 젠킨스( Jenkins)에서 사용되는 개념 중 하나로, 소스 코드 관리 시스템(Source Code Management, SCM)에서 파이프라인 스크립트를 가져와 실행하는 메커니즘을 나타냅니다.  

- 작성한 item의 Configure에서 Pipeline을 수정합니다.
- Pipeline
=> Definition : Pipeline script from SCM
=> SCM : git
=> Repository URL : https://github.com/github_username/web2024.git
=> Credentials : github_username/\*\*\*\*(github)
=> Branches to build  Branch Specifier (blank for 'any') : \*/main
=> Script Path
=> Spring10_Security_Thymeleaf_Jenkins/Jenkinsfile_first (github에서 만들 파일 명)
=> apply
=> 저장

![](../image/Pasted%20image%2020240513104510.png)

![](../image/Pasted%20image%2020240513104959.png)

![](../image/Pasted%20image%2020240513105017.png)

📌작업 완료하면 이런 화면이 나온다.

![](../image/전체과정_배포.txt)

## 두 번째 과정
![](../image/Pasted%20image%2020240513110921.png)

📌github에서 Jenkisfile_second 를 만든다.

![](../image/Pasted%20image%2020240513111048.png)

📌configuration => Pileline => Definition => Script Path => github repo에 저장된 프로젝트 폴더 + Jenkinsfile_second로 경로를 수정한다.

![](../image/Pasted%20image%2020240513111015.png)

📌configuration을 완료한 후, 지금 빌드를 누르면, Dockerizing / Login / Docker hub push / Cleaning up 등 새로운 항목이 추가되고 빌드가 이뤄진다.

![](../image/Pasted%20image%2020240513110720.png)

![](../image/Pasted%20image%2020240513110838.png)

![](../image/Pasted%20image%2020240513111827.png)

![](../image/Pasted%20image%2020240513112016.png)

📌이 과정이 잘 이루어졌다면, docker hub 들어가서 raynerius/security repositories에 들어가 본다. 이 안에서 세부 항목들을 보면 latests / 4(빌드 번호) 이렇게 새로운 image가 생긴 것을 확인할 수 있다.
- github에서 입력한 Jenkinsfile_second 파일의 56~57 라인에 의해서 latest / 4 라는 이미지가 생성된 것이다!
- docker hub에 push된 것은 91~107 라인에 의해서 수행된 것이다!

📌docker-compose 에서는 태그 번호를 입력해줘야 하는데, 그 번호를 항상 latest가 적용되게 하려고, latest 이미지를 만든 것이고, 1 2 3 4 ... 빌드 번호가 붙는 것은 중간 과정을 남기기 위해서 그런 것이다.


## 다른 EC2에 연결 하기 위한 과정
![](../image/Pasted%20image%2020240513120352.png)
📌전체과정_배포.txt 에서 15번 부터 진행하면 된다.

### 공개키와 개인키를 만듦
![](../image/Pasted%20image%2020240513120946.png)

![](../image/Pasted%20image%2020240513121258.png)

![](../image/Pasted%20image%2020240513121344.png)

![](../image/Pasted%20image%2020240513121912.png)

📌공개키와 개인키가 잘 만들어졌다. jenkins container에서 키페어를 생성했다. (예전에는 click으로 만들었다)

![](../image/Pasted%20image%2020240513122430.png)

📌배포용 EC2는 웹 상태에서 열어주는 게 편함. putty 하나 더 열면 좀 헷갈림.

![](../image/Pasted%20image%2020240513122714.png)

📌web-server 인스턴스를 연결