![[Pasted image 20240229090317.png]]
★웹은 인터넷이 아니다, 인터넷을 통해 제공하는 서비스 중에 하나
![[Pasted image 20240229090728.png]]
★Servelet : 컨트롤러 페이지 만들 때 사용(C)
★JSP : 뷰 페이지 만들 때 사용(V)
![[Pasted image 20240229091442.png]]
★톰캣(Tomcat)을 설치하면 JavaEE로 기능할 수 있다
- Java SE 프로그램은 개발자가 main( ) 메소드 안에 구현한 순서대로 실행된다. 즉, 프로그램이 실행되는 순서를 개발자가 제어한다. 그러나 Java EE 기반 프로그램은 실행의 흐름을 개발자가 제어하는 것이 아니라 컨테이너가 제어한다. 이처럼 개발자가 아 닌 제3자가 프로그램의 실행 흐름을 제어하는 것을 *IoC(Inversion of Control)* 라고 한다. 서블릿도 여기에 속한다.
- JAVA EE 기반 프로그램을 개발할 때는 먼저 애플리케이션 컨테이너들이 프로그램을 어떤 순서로 동작시키는지 알고 해당 순서에 맞게 개발해야 한다.
![[Pasted image 20240302114451.png]]
★서블릿 실행 순서
1. *클라이언트로부터 처리 요청받음*  클라이언트가 웹 브라우저를 통해 요청을 보내면 웹서버는 이를 받아서 요청정보의 헤더 안에 있는 URI를 분석한다. 이때, 요청받은 페이지가 서블릿이면 서블릿 컨테이너에 처리를 넘긴다. 서블릿 컨테이너는 요청받은 서블릿을 WEB-INF/classes나 WEB-INF/lib에서 찾아서 실행 준비를 한다.
2. *최초 요청 여부 판단*  서블릿 컨테이너는 현재 실행할 서블릿이 최초의 요청인지를 판단한다. 실행할 서블릿 객체가 메모리에 없으면 최초의 요청이고, 이미 있으면 최초의 요청이 아닌 것으로 판단한다. 최초 요청은 말 그대로 처음 요청할 때 딱 한 번만 실행된다.
3. *서블릿 객체 생성*  서블릿 컨테이너는 요청받은 서블릿이 최초 요청이라면 해당 서블릿응ㄹ 메모리에 로딩하고 객체를 생성한다. 일반 자바 객체는 new 명령문으로 여러 개의 객체를 언제든지 직접 생성할 수 있지만, 서블릿은 최초 요청이 들어왔을 때 한 번만 객체를 생성하고 이때 생성된 객체를 계속 사용한다.
4. *init( ) 메소드 실행*  init( ) 메소드는 서블릿 객체가 생성된 다음에 호출되는 메소드로, Servlet 인터페이스에 선언되어 있고, 기능은 GenericServlet 클래스에 구현되어 있다. init( ) 메소드는 처음 요청 시 서블릿 객체가 생성된 다음 호출되므로 주로 서블릿 객체의 초기화 작업이 구현되어 있다. GenericServlet 클래스에 구현된 내용을 바꾸고 싶다면 init( ) 메소드를 재정의하여 원하는 내용으로 변경하면 된다
5. *service( ) 메소드 실행* service( ) 메소드는 실행하는 서블릿의 요청 순서에 상관없이 클라이언트의 요청이 있을 때마다 실행된다. 따라서 service( ) 메소드에는 실제 서블릿에서 처리해야 하는 내용이 구현되어 있다. service( ) 메소드는 Servlet 인터페이스에 선언되어 있고, GenericServlet 클래스에 abstract 메소드로 선언되어 있으므로, HttpServlet 클래스에 메소드 몸체가 구현되어 있다. HttpServlet 클래스에 구현된 내용을 변경하고 싶다면 service( ) 메소드를 재정의하여 원하는 내용으로 변경하면 된다.
- service( ) 메소드가 끝나면 서버에서의 실행은 끝난다. 서버 프로그램 실행이 완료된 후에는 서블릿 컨테이너가 실행결과를 웹서버에 전달하고, 웹서버는 서비스를 요청한 클아이언트에 응답한다. 이로써 웹에서 하나의 요청에 대한 처리가 완료된다.
![[Pasted image 20240229091619.png]]
![[Pasted image 20240229091833.png]]
★웹 서버 : 클라이언트로부터 요청 받은 일과 화면에 표현하는 로직(Presentation Loginc)까지만 담당
★다양한 기능(ex DB처리)을 수행하는 로직(Business Loginc)은 컨테이너가 담당하도록 WAS에서 일을 나누어 역할을 분담한다
![[Pasted image 20240229091931.png]]
![[Pasted image 20240229091949.png]]
★톰캣(Tomcat) 은 WAS(Web Application Server)
- 웹 서버 / JSP 컨테이너 / Servlet 컨테이너를 제공한
![[Pasted image 20240229092147.png]]
![[Pasted image 20240229092154.png]]
★Servlet 
- 동적 웹 구현 기술
- 웹 서버 상에서 실행되는 자바의 클래스 파일
- 입력 / 출력을 HTTP 프로토콜의 요청(request)과 응답(response) 형태로 처리
- 장점
  1.자바를 기반으로 만들어져 객체 지향적, 플랫폼에 독립적인 자바 장점을 웹에서 구현
  2.스레드(Thread) 기반의 요청 처리 방식을 채택하여 사용자가 많을수록 효율적으로 동작한다
- 단점 : 화면 인터페이스 구현에 너무 많은 코드를 필요로 하는 등 비효율적
★tomcat10 이후로는 javax 패키지 => jakarta 패키지로 변경됨
★플랫폼에 독립적 : OS에 부합하는 JVM만 설치하면 된다
![[Pasted image 20240229092706.png]]
★스크립트 기반으로 개발되어 서버 페이지를 훨씬 쉽게 작성할 수 있다.
★서블릿과 함께 구동함으로써 서블릿 기능을 그대로 사용할 수 있다.
★JAVA 기반으로 view 페이지를 구현할 때 활용
★JSTL(JSP Standard Tag Library)을 지원하게 되면서 웹 프로그래밍 가독성이 좋아지고 유지 보수가 쉬워짐
![[Pasted image 20240229092753.png]]
![[Pasted image 20240229092805.png]]
★get 방식 : 외부 노출 / 보안에 취약하다

## Get방식 요청으로 인식되는 경우
![[Pasted image 20240229092932.png]]
1. 브라우저 주소 표시줄에 주소를 직접 입력해서 요청을 전송할 때
2. \<a> 태그를 사용하는 경우
3. \<form> 태그의 method 속성을 get로 지정하는 경우 / method 속성을 생략하는 경우
★서블릿은 get / post 방식에 따라 메소드를 별도로 적용해야 해서 구분하는 것 중요하다 (요청한 방식과 동일한 메소드를 활용해야 한다)
![[Pasted image 20240229093134.png]]
★톰캣은 JSP 컨테이너
![[톰캣설치 및 프로젝트 생성.docx]]
![[Pasted image 20240229095000.png]]
★webapps 폴더 안에 넣으면 배포 기능을 한다 (정해져있음)
- 서비스는 서버에서 애플리케이션 단위로 이루어진다. 웹서버마 다 시작될 때 자동으로 애플리케이션으로 인식하여 서비스를 올려주는 디렉토리가 있다.
- 톰캣은 톰캣을 설치한 디렉토리 하위의 webapps 디렉토리에 애플리케이션들이 있다. webapp 디렉토리에 있는 하위 디렉토리 또는 디렉토리가 압축된 war 파일은 하나의 애플리케이션으로 인식한다.
![[Pasted image 20240302103737.png]]
★톰캣에서는 예제로 제공하는 5개의 애플리케이션 디렉토리가 있고, 현재 톰캣 서버는 5개의 애플리케이션을 서비스하고 있다고 말할 수 있다.
![[Pasted image 20240229102215.png]]
★http://70.12.220.93:8080/edu/index.jsp
- *70.12.220.93* : 웹 애플리케이션을 서비스하는 웹서버가 설치된 컴퓨터 주소. 컴퓨터 주소는 아이피 주소 또는 도메인 이름으로 지정한다. 만일 서비스를 요청하는 클라이언트와 서버가 같은 컴퓨터에 있다면 컴퓨터의 주소(아이피 혹은 도메인) 대신 "localhost" 또는 "127.0.0.1"이라고 표시해도 된다. 이런 경우는 네트워크에서 컴퓨터를 찾는 과정이 생략되어 오프라인 상태에서도 테스트할 수 있다
- *8080*: 포트 번호로 서버를 찾아가기 위한 정보다. 컴퓨터 주소를 이용해 컴퓨터를 찾았다면 이제 해당 컴퓨터에서 서비스하는 서버 중 웹서버를 찾아야 한다. 웹서버가 사용하는 포트는 80번으로 예약되어 있으며 포트 번호를 생략하면 80으로 자동 인식한다. 포트 번호가 80이 아닐 때는 반드시 명시해주어야 한다. 웹서버를 설치할 때 설정한 포트 번호를 확인해야 한다.
- */edu* : 애플리케이션 이름이다. 포트 번호로 웹서버를 찾았다면 이제 웹 서버에서 서비스하는 애플리케이션을 찾아야 한다. 웹서버는 애플리케이션 단위로 서비스하기 때문이다
- */index.jsp* : 클라이언트가 요청한 최종 문서정보이다. 애플리케이션을 찾은 다음에는 해당 애플리케이션에서 서비스하는 문서를 찾아야 한다. 찾으려는 웹 문서의 경로는 파일시스템의 디렉터리 구조 형태로 지정한다. 즉, 루트 디렉터리(/)로 시작하여 하위 디렉터리로 내려가면서 파일을 찾는 경로를 지정한다.
★경로에 webapp 은 없다. webapp에는 .java 파일을 뺀 나머지(html, css 등)을 넣으면 되는 폴더임(개발자 편의 제공)


# １.servlet (서블릿)
★웹 브라우저에서 클라이언트의 요청에 따라 서버가 실행할 수 있는 자바 프로그램은 서블릿뿐이다. 이 말은 오직 오직 서블릿만이 웹에서 동작하는 특별한 조건을 가지고 있다는 뜻이다. 이러한 조건은 이미 서블릿 API를 통해 제공하고 있어서 직접 만들지 않아도 된다. 따라서 서블릿을 구현할 때 해당 API만 상속하면 웹에서 동작하는 기본 조건을 갖출 수 있다.
- *API?* Application Programming Interface [[240205_수업정리_JDBC시작#^e0a4ab|(링크) : 예전에 JDBC 시작할 때도 API를 검색한 적이 있다]]
- 이 포스팅도 조금 도움이 되는것 같다 https://www.hanl.tech/blog/api%EB%9E%80-api%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%A2%85%EB%A5%98-%EC%9E%A5%EB%8B%A8%EC%A0%90/
![[Pasted image 20240302110711.png]]
★서블릿 API 문서
★서블릿을 구현할 때 *jakarta.servlet.http 패키지*에 있는 *HttpServlet* 클래스를 반드시 상속받아야 한다.
★서블릿 프로그램의 클래스 계층 구조
 interface           :      servelt
abstract class     :     GenericServlet
abstract class     :     HttpServlet
- Servlet 인터페이스 : 서블릿 프로그램을 개발할 때 반드시 구현해야 하는 메소드를 선언하고 있는 인터페이스다. init( ), service( ), destory( ), getServletConfig( ), getServletInfo( ) 등 5개의 메소드를 선언하고 있는데, 이는 서블릿 프로그램 실행의 생명주기와 연관된 메소드이다.
- GenericServlet 클래스 : Servlet 인터페이스를 상속하여 클라이언트-서버 환경에서 서버단의 애플리케이션으로서 필요한 기능을 구현한 추상 클래스다. service( ) 메소드를 제외한 모든 메소드를 재정의하여 적절한 기능으로 구현했다. GenericServlet 클래스를 상속하면 애플리케이션의 프로토콜에 따라 메소드 재정의 구문을 적용해야 한다.
- HttpServlet 클래스 : GenericServlet 클래스를 상속하여 service( ) 메소드를 재정의함으로써 HTTP 프로토콜에 알맞은 동작을 수행하도록 구현한 클래스. 즉, HTTP 프로토콜 기반으로 브라우저로부터 요청을 전달받아서 처리하도록 하는 클래스다. service( ) 메소드에는 요청방식(GET 또는 POST)에 따라 doGet( ), doPost( ) 등 정해진 사양의 메소드가 호출되도록 구현되어 있다. HttpServlet 클래스를 상속받아 웹서버 기반의 서블릿 프로그램을 구현할 때 반드시 재정의해야 하는 메소드는 없으며, 어떠한 요청방식을 지원하는 서블릿인지에 따라서 필요한 메소드를 재정의하여 구현한다.


### ①web.xml 설정을 통해 클라이언트가 서블릿에 접근
![[Pasted image 20240229103802.png]]
★오류 뜨면 web-app 에서 version="4.0"으로 낮추면 된다
①실행할 서블릿을 웹서버에 등록
\<servlet>
	\<servlet-name>\</servlet-name>
	\<servlet-class>\</servlet-class>
\<servlet>
- *\<servlet> 태그*는 HttpServlet을 상속받고 있는 클래스를 web.xml에 등록할 때 사용한다. \<servlet>태그를 사용하려면 반드시 하위에 \<servlet-name>과 \<servlet-class> 태그를 가져야 한다.
- *\<servlet-name>* 태그는 등록하는 서블릿의 이름을 부여한다. 서블릿의 이름은 실제 존재하는 이름이 아닌 개발자가 지정하는 이름이다. 서블릿 이름으로 지정한 이후에는 클래스 이름을 사용하면 안 된다. 즉, \<servlet-name> 등록 후에는 서블릿 클래스 이름이 아닌 등록된 서블릿 이름으로 사용해야 올바르게 동작한다.
- *\<servlet-class>* 태그는 등록하는 서블릿의 실제 클래스 이름을 지정한다. \<servlet-class>에 지정된 정보로 웹서버가 서블릿 객체를 찾아 올바르게 서블릿에 관한 설정을 할 수 있다. 즉, \<servlet-class> 정보는 웹서버가 서블릿을 찾아갈 때 사용하는 정보로서 패키지명과 함께 대소문자를구분하여 정확하게 이름을 지정해야 한다
②\<servlet>으로 등록한 서블릿을 실행할 URI 지정
\<servlet-mapping>
	\<servlet-name>\</servlet-name>
	\<url-pattern>\</url-pattern>
\</servlet-mapping>
- *\<servlet-mapping>* 태그는 web.xml에서 \<servlet> 태그로 등록한 서블릿을 실행 요청할 때 사용할 url을 지정하기 위해 사용한다. 이 태그는 \<servlet> 태그를 사용했을 때만 부가적으로 사용할 수 있고, \<servlet>으로 등록된 서블릿이 아니면 사용할 수 없다
- *\<servlet-name>* 태그는 실행할 서블릿 이름을 지정한다. 이때 지정하는 이름은 반드시 \<servlet> 태그에서 등록한 서블릿 이름으로 지정해야 한다. 만약 \<servlet> 태그에서 등록하지 않은 이름으로 \<servlet-name>을 설정하면 web.xml 오류가 발생하여 웹 애플리케이션 서비스가 웹서버에 올라가지 않는다. 이 정보를 가지고 \<servlet> 태그를 찾아 *매핑(하나의 값을 다른 값으로 대응시키는 것)* 한 다음 실제 서블릿 클래스와 연결된다.
- *\<url-patter>* 태그는 서블릿을 실행할 때 사용할 url을 지정한다. 그런데 url을 지정할 때 전체 url 정보를 모두 지정하는 것이 아니고 *"\http://서버주소:포트번호/웹 애플리케이션 이름" 까지는 생략하고, 그 다음부터만 지정* 하면 된다(어차피 현재 웹 애플리케이션을 찾아오기까지의 정보는 고정되어 있으므로 생략 가능). 경로를 지정할 때는 /를 구분자로 하여 개발자 마음대로 정하면 된다. \<url-pattern> 태그에 경로를 지정하면 이다음부터는 지정된 경로로 접근하면 서블릿이 실행된다. 
![[Pasted image 20240229103813.png]]
![[Pasted image 20240229104517.png]]
![[Pasted image 20240229104744.png]]
★web.xml => 프로젝트 환경설정 파일. 배치기술자
- 웹 애플리케이션 실행에 관해 정의하는 환경설정 파일. 웹 애플리케이션 서비스 시작 시 웹서버가 읽어서 사용하는 파일이다
- 하나의 웹 애플리케이션 당 하나가 필요하다 (반드시 모든 웹 애플리케이션이 공통으로 가져야 하는 *디렉토리 : WEB-INF*, WEB-INF 디렉토리 안의 *web.xml* ) 또한, 현재 웹 애플리케이션에서 서비스하려는 클래스 파일이 있다면 WEB-INF/classes 디렉토리 하위에 있어야 하고, 클래스 파일들이 jar로 압축되어 있다면 WEB-INF/lib디렉토리에 있어야 한다. 클래스 파일들이 해당 위치에 있어야만 WAS를 구성하는 애플리케이션 서버들이 자동으로 인식할 수 있기 때문이다
- 웹 애플리케이션은 웹 컨테이너가 설치된 곳에 설치 되어 동작할 수 있다. 마치 하나의 프로그램을 다른 컴퓨터에 설치하는 것처럼 웹 애플리케이션 또한 웹 컨테이너가 설치되어 있는 곳에서 옮겨져서 실행될 수 있다. 이때 다른 곳에 배치될 웹 애애플리케이션이 그 시스템에 설치되어 있는 웹 컨테이너가 인식할 수 있도록 하는 내용들이 web.xml에 기술되어 있다.

#### 만들기
![[Pasted image 20240229110201.png]]
![[Pasted image 20240229110523.png]]
★JSP > Java Resources > src/main/java 에 Servlet 파일을 만든다
- Servlet은 웹페이지다
![[Pasted image 20240229110708.png]]
★request : 요청객체
★response : 응답객체
![[Pasted image 20240229111948.png]]
![[Pasted image 20240229112703.png]]
★실행하는 방법 : http://localhost:8088/JSP/(작성한 jsp 파일이름)
![[Pasted image 20240229114155.png]]
★요청이 들어오면 web.xml을 찾음 -> 서블릿 이름이 S_Test -> \_1.ServletTest에 S_Test 서블릿에 관한 정보가 있다 -> 해당 클래스로 이동하여 처리한다.
★요청과 응답이 끝나면 request, response 객체는 사라진다
![[Pasted image 20240229114454.png]]
#### 색 바꾸기
![[Pasted image 20240229114805.png]]
![[Pasted image 20240229120141.png]]



### ②@WebServlet을 통해 접근
![[URI,URL.jpg]]
★URI, URL 개념
- 요청 URI는 웹 클라이언트가 웹서버에 요청한 서비스 문서의 정보이다. 요청 URI는 네트워크의 자원 정보인 URL의 일부로서 URL(Uniform Resource Locator)은 네트워크상에 존재하는 자원을 찾아가기 위한 정보이다. url은 다음과 같은 형식을 표현한다
- *프로토콜* : 프로토콜은 서버와 통신하기 위한 규약으로, 서버마다 사용하는 프로토콜이 정해져 있다. 예를 들어, 웹서버는 URL에 \http://로 표현하며 오라클 DBMS는 jdbc:oracle:thin:@으로 표현한다.
- *서버주소* : 네트워크상에서 연결된 컴퓨터를 찾아가기 위한 정보로 IP주소 또는 도메인 이름으로 표현한다. 서버가 동작하고 있는 컴퓨터 정보이다.
- *포트번호* : URL에서 서버 주소를 이용해 컴퓨터를 찾았다면 포트 번호는 컴퓨터에서 동작하고 있는 서버로 접속하기 위한 정보다. 포트 번호는 0~65,535번까지 사용할 수 있으며, 0~1,023 사이의 번호는 well-known port로 이미 사용이 정의되어 있다. 예를 들어, 웹서버가 사용하는 포트 번호는 80포트로 정해져 있으며 만일 URL에서 http 프로토콜로 접속 시 포트 번호를 생략하면 자동으로 80포트로 인식한다. 80포트 이외의 포트 번호를 웹서버에 할당했을 때는 반드시 url에 명시해야 정상으로 접속된다.
- *URI* : Uniform Resource Identifier)는 서버에서 서비스하는 서버의 자원 정보이다. URL에서 포트 번호 다음부터가 URI이다<br><br> \http://www.mysite.com:80/edu/index.html  <br><br> 먼저 \www.mysite.com을 이용해 컴퓨터를 찾아오고, 다음 정보인 80을 이용해 서버를 찾아온다. 80 정보 다음부터가 접속한 서버에서 제공하는 자원정보로 이것을 URI라고 한다. 웹서버를 찾아오기까지 \www.mysite.com:80 정보를 사용하고, URI 정보로 웹서버에서 클라이언트가 요청한 문서를 찾아 실행한 후 결과를, 또는 그 파일 자체를 클라이언트에 응답한다.



★어노테이션(annotation)은 자바 주석문처럼 소스 안에 @ 기호와 함께 사용한다. 자바 실행문은 아니고 주석문처럼 컴파일러에게 정보를 알려주는 기능, 또는 자바프로그램 실행에 관한 내용을 설정하는 용도로 사용한다.
- @Override 어노테이션은 @Override 다음에 선언하는 메소드는 상속받은 메소드를 재정의하겠다고 명시하는 것이고 @SuppressWarnings는 컴파일러의 경고를 무시하겠다고 명시하는 것이다.
- 이전에는 웹 애플리케이션에서 사용하는 클래스를 등록하고 기능에 관한 내용을 설정하는 용도로 XML 파일을 사용했지만, 요즘에는 어노테이션을 많이 사용한다. @WebServlet 설정을 통한 서블릿 접근방법은 서블릿 3.0부터 지원한다. 서블릿 2.5버전까지는 web.xml 파일의 설정을 통해서만 서블릿에 접근할 수 있었다. 톰캣6은 서블릿 2.5를 지원하고 톰캣7이 서블릿 3.0버전을 지원하기 시작했다. 따라서 @WebServlet 어노테이션을 통한 서블릿 접근 방법은 톰캣7 버전부터 가능하다.
![[Pasted image 20240229120213.png]]
★어노테이션을 통해 접근하려면 서블릿의 클래스 선언부 앞에 @WebServlet(접근시 사용할 url)을 지정하면 된다.
- 이때, 어노테이션을 사용하려면 import 문으로 jakarta.servlet.annotation.WebServlet 클래스를 소스에 포함해야 한다
- url 입력할 때 */url* 형태로 입력해야 하는 것 주의
★urlPatterns 속성 생략하고 바로 url만 입력해도 된다
![[Pasted image 20240229120452.png]]
★@WebServlet 이후에 url을 동일하게 입력하면 오류 발생
![[Pasted image 20240229121752.png]]
★web.xml로 설정하는 게 불편해서 서블릿에 직접 @WebServlet 어노테이션을 추가하여 클라이언트가 서블릿에 접근할 수 있는 방법을 만들어낸 것이다. => 그런데 항상 이 방법이 좋은 것은 아님
- wb.xml 파일로 설정하는 방식은 여러 개의 서블릿을 태그로 등록하기 때문에 전체적인 관리가 쉽다. 또한, URL 값이 변경되어야 할 때는 소스를 수정하지 않고서도 web.xml에서 쉽게 변경할 수 있다. 그리고 @WebServlet 설정 방식은 설정파일 없이 자바 소스에서 @WebServlet으로 쉽게 URL 패턴을 지정할 수 있다. 그러나 하나의 자바 소스에 하나의 서블릿 매핑만 가능하므로 여러 개의 서블릿에 대한 정보를 일목요연하게 볼 수 없어서, web.xml에 설정하는 방법보다는 유지보수성이 떨어진다. 또한, URL 패턴값이 달라지면 소스를 수정해야 해서 다시 컴파일해야 한다.
★@webServlet 어노테이션 속성
- ![[Pasted image 20240303095321.png]]
- ![[Pasted image 20240303095700.png]]
![[Pasted image 20240229152253.png]]
![[Pasted image 20240229122319.png]]


#### 콜백 메소드 / 서블릿 객체의 생명주기
★클라이언트 요청 ~ 웹 서버 처리 순서
![[Pasted image 20240305090121.png]]
★콜백 메소드(callback method) : 어떤 객체에서 어떤 상황이 발생하면 컨테이너가 자동으로 호출하여 실행하는 메소드. 이러한 콜백 메소드들이 서블릿을 실행한다. HttpServlet 클래스를 상속받은 다음 재정의한 init( ), service( )가 콜백 메소드에 해당한다. 이 메소드들은 서블릿 객체에 어떤 상황(이벤트)이 발생하면 호출된다.
- init( ), service( ) 메소드 말고 서블릿의 콜백 메소드가 하나 더 있는데, GenericServlet 클래스에 선언되어 있는 destroy( ) 메소드임. destry( )는 메모리에서 서블릿 객체가 삭제될 때 호출되는 메소드다. 객체가 삭제될 때 호출되므로 자원을 해제하는 작업을 수행한다.
- ![[Pasted image 20240303084308.png]]
![[Pasted image 20240229123221.png]]
★serialVersionUID 자동 생성하는 방법 숙지
![[Pasted image 20240229124224.png]]
★서블릿이 실행될 때 service( ) 메소드가 자동으로 실행된다. HttpServlet 클래스에 구현된 service( ) 메소드를 재정의하여 메소드의 몸체를 구현해야 한다. 서블릿 요청이 있을 때마다 호출되는 메소드이므로 반드시 재정의해야 한다. but!!! service( ) 메소드를 재정의하지 않을 때가 있다. HttpServlet에서 구현된 service( ) 메소드를 그대로 실행하고 싶을 때이다. HttpServlet 클래스의 service( ) 메소드는 두 가지 형태로 정의되어 있다. 
①protected void service(HttpServletRequest req, HttpServletResponse resp)
②public void service(ServletRequest req, ServletResponse resp)
이 중 서블릿 요청이 있을 때마다 실행되는 메소드는 ②번 형태의 service( )이다. 그런데 ②형태의 service( )는 단순히 같은 객체에 있는 ① 형태의 service( ) 메소드를 호출만 해준다. ① 형태의 service( ) 메소드는 클라이언트의 실행요청에 따라 서로 다른 메소드를 호출하도록 구현되었다. 클라이언트가 서버에 서비스를 요청했다는 것은 요청정보를 보냈다는 것이며, 요청정보는 다음과 같은 정보로 이루어져 있다.
- ![[Pasted image 20240303101755.png]]
요청방식은 GET, POST, PUT, DELETE 등이 있다. 앞서 ①형태의 service( ) 메소드는 바로 이 요청방식 정보를 추출한 후 추출된 요청방식 정보에 따라 서로 다른 메소드를 호출하도록 구현되어 있다. 이때 호출하는 메소드는 HttpServlet 클래스에서 선언하고 있는 다음 메소드들이다
- ![[Pasted image 20240303104523.png]]
메소드 이름의 특징을 보면 do 다음에 요청방식 이름이 나온다. 클라이언트가 GET 방식으로 요청했다면 doGet( ) / POST 방식으로 요청했다면 doPost( ) 메소드를 호출한다. 만약 똑같은 URI 요청을 요청방식에 따라 서로 다르게 동작하게 하려면 service( ) 메소드를 재정의하지 말고 HttpServlet 클래스의 service( ) 메소드가 실행되도록 한 다음, doGet( ) 또는 doPost( ) 메소드 등이 실행되도록 이 메소드들을 재정의하여 구현한다.
service( )메소드를 재정의할 것인지, doGet( ), doPost( ) 메소드를 재정의할 것인지는 개발자가 상황에 맞게 적절하게 선택하면 되는데, 이것을 반드시 구분해야 하는 경우가 있다. 예를 들면, 클라이언트가 웹 화면에서 무엇인가를 작성하여 서버에 제출하는 서비스가 있다. 한 번 제출한 상태에서 웹 브라우저 화면에서 새로고침 버튼을 누르면 두 번 제출되는 사례가 있다. 이러한 예가 발생하지 않게 하려면 서버에 제출할 때 POST 방식으로 요청하고, doPost( ) 메소드에 서비스 처리를 구현하면 된다. doPost( ) 메소드는 POST 방식으로 요청이 들어올 때만 실행되는 메소드이므로 웹브라우저에서 새로고침 버튼이나 웹 브라우저 주소 줄에서 재요청을 해도 실행되지 않는다.
★LifeCycle을 입력했을 때는 요청과 응답 관련된 객체를 생성했는데  a를 입력했을 때는 service 메소드만 호출한다
- init( ) 메소드 호출 X service( )만 호출한다
![[Pasted image 20240229124831.png]]
★LifeCycle.java 파일에서 아무곳에나 엔터를 입력한 후 저장(기존의 클래스가 바뀜 -> 이전의 클래스는 삭제된)하면, 위와 같이 destroy( ) 메소드가 호출된 것을 알 수 있다
![[Pasted image 20240229140311.png]]
★서블릿 객체가 메모리에 생성되는 시점은 서버 입장에서 클라이언트로부터 최초로 서블릿 실행 요청이 있을 때이다. (*클라이언트 입장이 아니고 서버입장이다.* 어떤 클라이언트가 요청했는지는 중요하지 않다) 서버 입장에서 최초로 서블릿 요청이 있을 때, 서블릿 컨테이너는 해당 서블릿 객체를 메모리에 생성한 다음, init( ) -> serivce( ) 순으로 실행한다. 이후 같은 서블릿 실행 요청이 있으면 최초 요청 시 생성한 서블릿 객체의 service( ) 메소드를 실행한다. 클라이언트로부터 서블릿 요청이 있을 때마다 요청이 최초인지를 판단하는 기준은 *객체 생성 여부*다 중요한 사실은 *요청이 있을 때마다 서블릿 객체를 생성하는 것이 아니고, 최초 요청 때 생성한 서블릿 객체를 계속 사용한다는 것이다.* 이전의 다른 CGI 프로그램들은 요청이 있을 때마다 독립적으로 처리되었지만, 서블릿은 한 번 생성한 객체를 재사용하는 거라서 처리속도, 메모리 부분에서 이전의 기술보다 효율적인 장점이 있다.
★최초 요청 시 생성된 서블릿 객체가 삭제되는 시점은 *서버를 중지시켜 웹 애플리케이션 서비스를 중지할 때이다.* 웹서버에서는 전체 서비스를 중지할 수도 있고, 일부 서비스만 중지할 수도 있다. 어떤 상황이든지 서블릿 객체가 삭제되는 시점은 웹서버에서 웹 애플리케이션 서비스가 중지되는 시점이다. 이때 destroy( ) 메소드가 호출되어 실행된다. 그래서 destroy( ) 메소드에는 자원을 해제하는 내용을 구현하면 알맞다.


★클라이언트의 요청에 따른 서블릿의 메소드 실행 순서를 정리하면 다음과 같다
①init(ServletConfig) -> GenericServlet
②service(ServletRequest, ServletResponse) -> HttpServlet
③service(HttpServletRequest, HttpServletResponse) -> HttpServlet
④doGet(HttpServletRequest, HttpServletResponse) -> SecondServlet



### JSP로 만들어보기
![[Pasted image 20240229140817.png]]

#### JSP 작동원리
★정적인 페이지에 대한 요청, 즉 HTML / 여러 이미지 / 텍스트 파일들에 대한 요청은 웹 서버에서 해결한다. 그리고 동적인 페이지에 대한 요청, 즉 JSP 페이지에 대한 요청은 웹 서버에서 JSP 컨테이너로 다시 전달된다. 이렇게 해서 JSP 페이지가 웹 컨테이너에 의해 실행된다.
1. 사용자의 브라우저에서 \http://servername.../~.jsp 형태로 요청
2. 웹 서버는 ~.jsp 형태로 온 요청에 대해 JSP 컨테이너로 처리하게끔 요청 정보를 넘긴다
3. 해당 JSP 파일이 처음 요청된 것이면 JSP 파일을 *파싱*한다. 이전에 요청된 것이면 6번 단계로 넘어간다. JSP 파일은 실행을 위해 결국 클래스 파일로 변환되는데 이런 과정은 jsp, 파일이 처음으로 호출되었을 때에만 거친다. 만일 이전에 어떤 jsp 파일이 호출되었다면 2번째 이후로 들어온 해당 jsp 파일의 요청에 대해서 4, 5 단계의 생성 및 변환 과정은 거치지 않게 된다
4. JSP 파일로부터 "서블릿"이라는 새로운 자바 파일이 생성된다. JSP 파일을 기본으로 해서 서블릿이라는 자바 파일이 새롭게 생성된다
5. 서블릿 파일은 실행 가능한 상태인 클래스 파일로 컴파일 된다.
6. 클래스 파일이 메모리에 적재 되어 실행된다
7. 클래스 파일의 실행결과는 다시 웹 서버에게 넘겨져 웹 서버는 HTML 형태로 사용자에게 응답 내용을 전송한다. 처음에 사용자가 JSP 파일을 요청한 것에 대한 응답으로 HTML 형태의 내용을 전송하게 된다
8. 웹 서버로부터 받은 응답인 HTML로 구성된 페이지를 브라우저에서 실행시켜 웹 페이지가 보이게 된다. 웹 브라우저는 HTML 태그로 구성된 페이지를 실행시켜주는 프로그램이다
★ 파싱 : 서블릿이라는 파일을 JSP 컨테이너가 만들어 내기 위해 JSP가 어떤 작업을 하는 파일인지 알아야 한다. 그러기 위해서 JSP 파일을 정확하게, 오타나 논리적인 오류가 없는지에 대해서 읽는 과정
★매번 요청이 있을 때마다 메모리에 적재되는 것은 아니다. 서블릿 파일이 생성된 후 컴파일 되어 메모리에 적재 되면(*객체 생성*) *매번 요청이 해당 서블릿으로 들어 올 때마다 스레드 기반 하에 작은 프로세스를 생성하여 여러 개의 동시 요청을 처리*하게 된다. => *모든 요청시마다 매번 메모리에 적재되는 방식이 아니다*
![[Pasted image 20240229141225.png]]
★입력값을 보기 위한 주소 : \http://localhost:8088/JSP/\_1/ServletTest.jsp
- 매핑을 하지 않는 건가?



## loginform
![[Pasted image 20240229142018.png]]
★예제 경로 : \http://localhost:8088/JSP/ex1/\_1.login/login1_get.html
![[Pasted image 20240229142320.png]]
![[Pasted image 20240229143938.png]]



![[Pasted image 20240229150559.png]]
![[Pasted image 20240229150339.png]]
![[Pasted image 20240229152247.png]]
![[Pasted image 20240229152253.png]]




## post
![[Pasted image 20240229153517.png]]
![[Pasted image 20240229153912.png]]
![[Pasted image 20240229153927.png]]
![[Pasted image 20240229153943.png]]




## 문제
![[Pasted image 20240229154953.png]]
![[Pasted image 20240229155616.png]]
![[Pasted image 20240229160938.png]]
![[Pasted image 20240229163829.png]]
![[Pasted image 20240229164157.png]]
★모든 태그를 작성할 수 있다
★외부 스타일시트 \<link rel=   type=   href=   >
★servlet은 front 구현하기가 귀찮다..



# 240229_과제
![[Pasted image 20240229170634.png]]
![[Pasted image 20240229171633.png]]
![[Pasted image 20240229173523.png]]
![[Pasted image 20240229173123.png]]
![[Pasted image 20240229173222.png]]
★column 반복문 -> 선택한 것만큼
★java 폴더에는 java 파일만 들어가고 webapp에는 이외의 모든 파일

